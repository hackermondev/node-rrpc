import { Redis } from 'ioredis';
import { RRPCBase } from './Base';
import { ICreateChannPacket } from '../types/messages';
import { Channel, ChannelState } from './Channel';
import { MessageOps } from '../types/ops';

export declare interface RRPCServer {
    on(event: 'connection', listener: (channel: Channel) => void): this;
}

export class RRPCServer extends RRPCBase {
    public running: boolean;
    public channels: Channel[];
    private _messageCallback?: (channel: string, message: string) => void;

    constructor(serverName: string, redis: Redis, baseName = 'rrpc') {
        super(baseName, redis);
        this.server_name = serverName;
        this.running = false;
        this.channels = [];
    }

    private async renewSubscription() {
        if (!this.running) return;

        // this.debug('running renew subscription');
        const name = `rrpc:${this.name}/${this.server_name}/subscription/${this.id}`;
        await this.redis2.set(name, '1');
        await this.redis2.expire(name, 1);

        setTimeout(() => this.renewSubscription(), 1_000 - 1).unref();
    }

    async run() {
        const Channel0 = `rrpc:${this.name}/${this.server_name}/${this.id}/channel0`;
        this.running = true;
        this.renewSubscription();

        this._messageCallback = (channel, message) => {
            if (channel != Channel0) return;

            // The client requests a new channel
            // Connection details are sent to the server in channel0
            /*
                {
                    "op": "createchan",
                    "name": String, // name of rpc server name (our name, not required)
                    "id": String, // Connection ID, generated by client
                }
            */

            const data = this.parseIncomingMessage(Buffer.from(message));
            this.debug(channel, data);
            if (data.op != MessageOps.CreateChannelRequest) return;

            this.debug('creating channel', data);
            const chann = new Channel(this, 'server');
            chann.connect(data as ICreateChannPacket);
            this.channels.push(chann);

            chann.on('connect', () => this.emit('connection', chann));
        };

        this.redis.on('message', this._messageCallback);
        await this.redis.subscribe(Channel0);
    }

    async close(
        {
            closeAllActiveChannels,
        }: { closeAllActiveChannels: boolean; forceCloseChannels: boolean } = {
            closeAllActiveChannels: true,
            forceCloseChannels: false,
        },
    ) {
        this.running = false;
        await this.redis2.del(`rrpc:${this.name}/${this.server_name}/subscription/${this.id}`);
        const Channel0 = `rrpc:${this.name}/${this.server_name}/${this.id}/channel0`;
        await this.redis.unsubscribe(Channel0);

        if (this._messageCallback) this.redis.removeListener('message', this._messageCallback);
        if (closeAllActiveChannels)
            this.channels
                .filter((c) => c.state == ChannelState.FullyConnected)
                .map((c) => c.close());
    }
}
