import { Redis } from 'ioredis';
import { RRPCBase } from './Base';
import { ICreateChannPacket } from '../types/messages';
import { Channel, ChannelState } from './Channel';
import { MessageOps } from '../types/ops';

export declare interface RRPCServer {
    on(event: 'connection', listener: (channel: Channel) => void): this;
}

export class RRPCServer extends RRPCBase {
    public running: boolean;
    public channels: Channel[];

    constructor(serverName: string, redis: Redis, baseName = 'rrpc') {
        super(baseName, redis);
        this.server_name = serverName;
        this.running = false;
        this.channels = [];
    }

    private async renewSubscription() {
        if (!this.running) return;

        const name = `${this.name}/${this.server_name}/subscription/${this.id}`;
        await this.redis2.set(name, '1');
        await this.redis2.expire(name, 1_000);

        setTimeout(() => this.renewSubscription(), 1_000 - 1).unref();
    }

    async run() {
        const Channel0 = `${this.name}/${this.server_name}/${this.id}/channel0`;
        this.redis.subscribe(Channel0);
        this.running = true;
        this.renewSubscription();
        this.redis.on('message', (channel, message) => {
            if (channel != Channel0) return;

            // The client requests a new channel
            // Connection details are sent to the server in channel0
            /*
                {
                    "op": "createchan",
                    "name": String, // name of rpc server name (our name, not required)
                    "id": String, // Connection ID, generated by client
                    "type": "oneway" | "stream" // Channel connection type. 
                        oneway = Simple one message send/recieve then channel end
                        stream = Keep connection open and send and recieve anytime until channel ends
                }
            */

            const data = this.parseIncomingMessage(Buffer.from(message));
            this.debug(channel, data);
            if (data.op != MessageOps.CreateChannelRequest) return;

            this.debug('creating channel', data);
            const chann = new Channel((data as ICreateChannPacket).type, this, 'server');
            chann.connect(data as ICreateChannPacket);
            this.channels.push(chann);

            this.emit('connection', chann);
        });
    }

    async close(
        {
            closeAllActiveChannels,
            forceCloseChannels,
        }: { closeAllActiveChannels: boolean; forceCloseChannels: boolean } = {
            closeAllActiveChannels: true,
            forceCloseChannels: false,
        },
    ) {
        const Channel0 = `${this.name}/${this.server_name}/channel0`;
        await this.redis.unsubscribe(Channel0);

        this.running = false;
        if (closeAllActiveChannels)
            this.channels
                .filter((c) => c.state == ChannelState.FullyConnected)
                .map((c) => c.close(forceCloseChannels));
    }
}
